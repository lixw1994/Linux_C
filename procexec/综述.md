1. fork() exit() wait() 以及 evecve()简介

	系统调用fork()允许父进程创建一个子进程；新的子进程几近于父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。
	库函数exit(status) 终止一个进程，将进程所占的所有资源(内存、文件描述符等)归还给内核；参数status为一整形变量，表示进程退出状态。父进程可使用wait()获取该状态。
	系统调用wait(&status)目的有二：如果子进程尚未调用exit()终止，那么wait()会挂起父进程直到子进程终止；其二，子进程的终止状态通过wait()返回。
	系统调用execve(pathname, argv, envp)加载一个新程序到当前进程的内存；这将丢弃现存的程序文本段，并未新程序重新创建栈、数据段以及堆。

2. 创建新进程：pid_t fork(void);
	理解fork()的诀窍是：要意识到，完成对其调用后将存在两个进程，且每个进程会从fork()的返回处继续执行。
	执行fork()后，每个进程可以修改自己的栈数据和堆而不影响另外一个进程。
	父子进程间的文件共享：执行fork()时，子进程会获得父进程所有的文件描述符的副本，指向相同的打开文件句柄。打开文件句柄中包含的文件偏移量以及文件状态标识都会实现共享；也就是说，如果子进程改变的打开文件的属性，也会影响到父进程。
3. 控制进程的内存需求
	通过fork()和wait()的组合使用，可以控制一个进程的内存需求。进程的内存需求量，也就是进程所使用虚拟内存页的范围，受到多种因素的影响，例如，调用函数，或从函数返回时栈的变化情况，对exec()的调用，以及malloc和free对堆所做的修改。

4. vfork():是为子进程立即执行exec()的程序专门设计的
	vfork()因为下面两个特性而更具效率：无需为子进程复制虚拟内存或页表，相反，子进程共享父进程的内存，直至成功执行了exec()或者_exit()退出； 在子进程调用exec()或_exit()之前，将暂停父进程。
	除非速度绝对重要的场合，新程序应当舍弃

5. 同步信号以规避竞争条件
	调用fork()之后，进程甲需要等待进程乙完成某一动作，那么乙(即活动进程)可在动作完成后向甲发送信号；甲等待即可。

6. 监控子进程的状态：在很多程序设计中，父进程需要某个子进程何时改变了状态----子进程终止
	或者收到信号而停止。将要学习两种技术：系统调用wait()及其变体 和 信号SIGCHLD
7. wait()方法有诸多限制，设计waitpid()意在突破这些限制：
	# 如果父进程创建了多个子进程，使用wait将无法等待某个特定的子进程完成。
	# 如果没有子进程退出，wait()会一直保持阻塞，有时希望执行非阻塞等待，是否有子进程退出
		立判可知。
	# 使用wait()只能发现已经终止的进程，而对于子进程因为某个信号(SIGSTOP)停止或者因为
		某个信号(SIGCONT)恢复执行的情况就无能为力了。

8. pid_t waitpid(pid_t pid, int* status, int options);
	如果pid>0, 表示等待特定(即pid)子进程.
	如果pid==0, 表示等待与调用进程(父进程)同一个进程组的所有子进程
	如果pid<-1, 表示等待进程组标识符与pid决定值相等的所有子进程
	如果pid==-1, 表示等待任意子进程。

9. SIGCHLD信号：
	子进程的终止属于异步事件，父进程无法预知子进程何时终止。(即使父进程向子进程发送SIGKILL信号
	子进程确切的终止时间还是依赖于系统的调度：子进程下一次合适取得CPU。)系统需要使用wait()系列
	的函数来防止僵尸进程的积累：
		父进程调用不带WNOHANG表示的wait系列，此时若尚无已经终止的子进程，那么调用将会阻塞。
		父进程周期性地调用带有WNOHANG标志的waitpid()，执行针对已终止子进程的非阻塞检查(轮询)
	但是上述两种方法使用起来都有不便。一方面，可能不希望父进程以阻塞的方式等待子进程的终止。另一方面，反复调用非阻塞的waitpid()会造成CPU资源的浪费，并增加应用程序设计的复杂度。
10. 无论一个子进程何时终止，系统都会向父进程发送一个SIGCHLD信号。可以为该信号安装处理器程序来解决
	上述不足。要注意的是，当调用信号处理器程序时，会暂时将引发调用的信号阻塞起来(除非sigaction
	指定了SA_NODEFER)，且不会对SIGCHLD之流的信号做排队处理。解决办法是，在SIGCHLD处理程序
	内部循环以WNOHANG标志来调用waitpid()，直到再无其他子进程需要处理为止。
















