1. fork() exit() wait() 以及 evecve()简介

	系统调用fork()允许父进程创建一个子进程；新的子进程几近于父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝。
	库函数exit(status) 终止一个进程，将进程所占的所有资源(内存、文件描述符等)归还给内核；参数status为一整形变量，表示进程退出状态。父进程可使用wait()获取该状态。
	系统调用wait(&status)目的有二：如果子进程尚未调用exit()终止，那么wait()会挂起父进程直到子进程终止；其二，子进程的终止状态通过wait()返回。
	系统调用execve(pathname, argv, envp)加载一个新程序到当前进程的内存；这将丢弃现存的程序文本段，并未新程序重新创建栈、数据段以及堆。

2. 创建新进程：pid_t fork(void);
	理解fork()的诀窍是：要意识到，完成对其调用后将存在两个进程，且每个进程会从fork()的返回处继续执行。
	执行fork()后，每个进程可以修改自己的栈数据和堆而不影响另外一个进程。
	父子进程间的文件共享：执行fork()时，子进程会获得父进程所有的文件描述符的副本，指向相同的打开文件句柄。打开文件句柄中包含的文件偏移量以及文件状态标识都会实现共享；也就是说，如果子进程改变的打开文件的属性，也会影响到父进程。
3. 控制进程的内存需求
	通过fork()和wait()的组合使用，可以控制一个进程的内存需求。进程的内存需求量，也就是进程所使用虚拟内存页的范围，受到多种因素的影响，例如，调用函数，或从函数返回时栈的变化情况，对exec()的调用，以及malloc和free对堆所做的修改。

4. vfork():是为子进程立即执行exec()的程序专门设计的
	vfork()因为下面两个特性而更具效率：无需为子进程复制虚拟内存或页表，相反，子进程共享父进程的内存，直至成功执行了exec()或者_exit()退出； 在子进程调用exec()或_exit()之前，将暂停父进程。
	除非速度绝对重要的场合，新程序应当舍弃

5. 同步信号以规避竞争条件
	调用fork()之后，进程甲需要等待进程乙完成某一动作，那么乙(即活动进程)可在动作完成后向甲发送信号；甲等待即可。

6. 监控子进程的状态：在很多程序设计中，父进程需要某个子进程何时改变了状态----子进程终止
	或者收到信号而停止。将要学习两种技术：系统调用wait()及其变体 和 信号SIGCHLD