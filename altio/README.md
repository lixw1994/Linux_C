                                IO整体概览
    目前为止，本书中大部分的程序使用的IO模型都是单个进程每次只在一个文件描述符上执行IO操作，每次
IO系统调用都是阻塞直到完成数据传输。比如，当从一个管道中读取数据时，如果管道中恰好没有数据，那么通常read 会阻塞；而如果管道中没有足够的空间写入数据时，write也会阻塞。当在其他类型的文件入FIFO和套
接字上执行IO操作时，也会出现类似的行为。
    对于许多应用来说，传统的阻塞式IO模型已经足够了，但是并不是所有的应用都可以得到满足。特别的，有
时候应用需要处理一下某项任务，或者两者都需要兼顾：
    ✅ 如果可能的话，以非阻塞的方式检查文件描述符上是否可以进行IO操作。
    ✅ 同时检查多个文件描述符，看他们中是否任何一个可以执行IO操作。
    我们已经遇到了两种可以部分满足这些需求的技术：非阻塞式IO和多进程或多线程技术。
    如果在打开文件时设定了O_NONBLOCK标志，会以非阻塞的方式打开文件。如果IO系统调用不能立即完成
，则会返回错误而不是阻塞进程。非阻塞式IO可以运用到管道、FIFO、套接字、终端、伪终端等等类型上。非阻塞式IO可以让我们周期性地检查(轮询)某个文件描述符上是否可以执行IO操作。比如，我们可以让一个输入文件
描述符成为非阻塞的，然后周期性地执行非阻塞式的读操作。如果我们需要同时检查多个文件描述符那么需要将他们都设为非阻塞，然后依次轮询。但是这种轮询是我们不希望看到的。如果轮询频率不高，那么应用程序响应IO事件的延迟可能达到无法接受的程度。换句话，在一个紧凑的循环中做轮询就是浪费CPU。
    如果不希望进程在对文件描述符执行IO时被阻塞，我们可以创建一个新的进程来执行IO。此时父进程就可
以去处理其他的任务了，而子进程将阻塞知道IO操作完成。如果我们需要在多个文件描述符上执行IO，此时可以为每个文件描述符创建一个子进程。这种方法的问题在于开销昂贵且复杂。创建和维护进程都有开销，而且需要涉及到IPC通信。
    使用多线程而不是多进程，这将占有较少的资源。但是线程之间依然需要通信，以告知其他线程有关IO操作
的状态，这将使编程工作变得复杂。尤其是如果我们使用线程池技术来最小化处理大量并发客户的线程数量时。
（多线程一个特别有用的地方是如果应用程序需要调用一个会执行阻塞式IO操作的第三方库，那么可以在分离的线程中调用避免被阻塞。）
    由于非阻塞式和多进程(多线程)都有各自的局限性，下列备选方案更可取：
    ✅ IO多路复用允许进程同时检查多个文件描述符以找出他们中任何一个是否可以执行IO操作。
        系统调用select 和 poll 来执行多路复用。
    ✅ 信号驱动IO是指当有输入或者有数据可以写到执行的文件描述符时，内核向请求数据的进程发送一个
        信号。进程可以处理其他任务，当IO操作可执行时通过接受信号来获得通知。当同事检查大量文件描述符时，信号驱动比select和poll有显著的性能提升。
    ✅ epoll API是Linux专有的特性，首次出现在Linux2.6版。同IO多路复用API一样，epoll允许
        进程同时检查多个文件描述符，看其中任意一个是否能执行IO操作。同信号驱动IO一样，当同事检查大量的文件描述符时，epoll提供更好的性能。
    需要注意的是这些技术都不会执行实际的IO操作。它们只是告诉我们某个文件描述符已经处于就绪状态了。

                            水平触发和边缘触发
    文件描述符的准备就绪通知模式：
    ✅ 水平触发通知：如果文件描述符上可以飞阻塞的执行IO系统调用，此时认为它已经就绪。
    ✅ 边缘触发通知：如果文件描述符自上次检查依赖有了新的IO活动，此时需要触发通知。
    注意：在备选IO模型中采用非阻塞IO






