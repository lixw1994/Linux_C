1. 发送信号：kill() 注意：不是杀死
	之所以选择kill作为术语，因为早期UNIX实现大多数信号默认行为是终止进程。。。
	int kill(pid_t pid, int sig); 	// pid参数很有讲究
	 pid > 0, 那么会发送信号给pid指定进程
	 pid = 0, 会发送信号给与调用进程同组的每个进程
	 pid < -1, 会向组ID等于pid绝对值的进程组内所有下属进程发送信号
	 pid = -1, 调用进程有权将信号发给每个目标进程(出去init和自身)，即广播信号
	kill()系统调用还有另一重用，若将参数sig置为0(即空信号)，则无信号发送；相反，kill()仅会去做错误检查，查看是否可以向目标进程发送信号。从另一个角度看，可以用空信号来检测目标进程是否存在。若空信号发送失败，且errno置为ESRCH，则表明目标进程不存在；如果调用失败，且errno置为EPERM，则表示进程存在，但是无权向其发送信号；或者调用成功，两种情况都满足。
	要注意的是，验证ID存在并不能保证某一特定程序仍在运行；因为内核会循环使用ID，也有可能ID是一个僵尸状态。 ***需要使用其他技术检查某一特定程序是否正在运行***。
2. 发送信号的其他方式
	进程有可能需要向自己发送信号；
	int raise(int sig);	其相当于
	单线程：kill(getpid(), sig);
	多线程：pthread_kill(pthread_self(), sig);
	向某一进程组所有成员发送信号
	int killpg(pid_t pgrp, int sig);

3. 显示信号描述
	#define _BSD_SOURCE
	#include <signal.h>
	extern const char* const sys_siglist[];

	#define _GNU_SOURCE
	#include <string.h>
	char* strsignal(int sig);

	#include <signal.h>
	void psignal(int sig, const char* msg);

4. 信号集：sigset_t数据结构（似乎是Linux特有）
	// 初始化
	int sigemptyset(sigset_t* set);
	int sigfillset(sigset_t* set);
	// 向一个集合中添加或者移除信号
	int sigaddset(sigset_t* set, int sig);
	int sigdelset(sigset_t* set, int sig);
	// 测试sig是否在set中
	int sigismember(const sigset_t* set, int sig);

5. 信号掩码（阻塞信号传递）
	内核会为每个进程维护一个信号掩码，即一组信号，并阻塞其针对该进程的传递(实际属于线程属性)。
	向信号掩码添加一个信号：
	int sigprocmask(int how, const sigset_t* set, sigset_t* oldset);
	信号掩码这个等待信号集仅表明信号是否发生，而未表明信号发生的次数。换言之，如果在同一信号下阻塞状态下产生多次，那么会将信号记录在等待信号集中，并在稍后传递一次。























