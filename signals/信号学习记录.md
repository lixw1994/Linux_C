0. 综述：信号到达后，进程视具体信号执行如下默认操作之一：
	<1> 忽略信号：也就是说，内核将信号丢弃，信号对进城没有产生任何影响(进程都不知道该信号出现过)
	<2> 终止进程：有时是指进程异常终止，而不是调用exit()的正常终止。
	<3> 产生核心转储文件，并终止进程：核心转储文件包含对进程虚拟内存的镜像，可将其加载到
	虚拟调试器中检查进程终止的状态。
	<4> 停止进程：暂停进程的执行。
	<5> 恢复进程：恢复之前暂停的进程。
	除了根据特定信号采取默认行为外，程序也能改变信号到达时的响应行为，称为对信号的处置设置。
	可以设置如下处置：
	<1> 采取默认行为
	<2> 忽略信号
	<3> 执行信号处理器程序(由程序员自己负责)
1. 发送信号：kill() 注意：不是杀死
	之所以选择kill作为术语，因为早期UNIX实现大多数信号默认行为是终止进程。。。
	int kill(pid_t pid, int sig); 	// pid参数很有讲究
	 pid > 0, 那么会发送信号给pid指定进程
	 pid = 0, 会发送信号给与调用进程同组的每个进程
	 pid < -1, 会向组ID等于pid绝对值的进程组内所有下属进程发送信号
	 pid = -1, 调用进程有权将信号发给每个目标进程(出去init和自身)，即广播信号
	kill()系统调用还有另一重用，若将参数sig置为0(即空信号)，则无信号发送；相反，kill()仅会去做错误检查，查看是否可以向目标进程发送信号。从另一个角度看，可以用空信号来检测目标进程是否存在。若空信号发送失败，且errno置为ESRCH，则表明目标进程不存在；如果调用失败，且errno置为EPERM，则表示进程存在，但是无权向其发送信号；或者调用成功，两种情况都满足。
	要注意的是，验证ID存在并不能保证某一特定程序仍在运行；因为内核会循环使用ID，也有可能ID是一个僵尸状态。 ***需要使用其他技术检查某一特定程序是否正在运行***。
2. 发送信号的其他方式
	进程有可能需要向自己发送信号；
	int raise(int sig);	其相当于
	单线程：kill(getpid(), sig);
	多线程：pthread_kill(pthread_self(), sig);
	向某一进程组所有成员发送信号
	int killpg(pid_t pgrp, int sig);

3. 显示信号描述
	#define _BSD_SOURCE
	#include <signal.h>
	extern const char* const sys_siglist[];

	#define _GNU_SOURCE
	#include <string.h>
	char* strsignal(int sig);

	#include <signal.h>
	void psignal(int sig, const char* msg);

4. 信号集：sigset_t数据结构（似乎是Linux特有）
	// 初始化
	int sigemptyset(sigset_t* set);
	int sigfillset(sigset_t* set);
	// 向一个集合中添加或者移除信号
	int sigaddset(sigset_t* set, int sig);
	int sigdelset(sigset_t* set, int sig);
	// 测试sig是否在set中
	int sigismember(const sigset_t* set, int sig);

5. 信号掩码（阻塞信号传递）
	内核会为每个进程维护一个信号掩码，即一组信号，并阻塞其针对该进程的传递(实际属于线程属性)。
	向信号掩码添加一个信号：
	int sigprocmask(int how, const sigset_t* set, sigset_t* oldset);
	信号掩码这个等待信号集仅表明信号是否发生，而未表明信号发生的次数。换言之，如果在同一信号下阻塞状态下产生多次，那么会将信号记录在等待信号集中，并在稍后传递一次。

6. 改变信号处置：sigaction();
	int sigantion(int sig, const struct sigaction* act, struct sigaction* act);
	// 利用sigaction结构体实现信号处理

7. 设计信号处理器函数：一般而言，设计的越简单越好，目的是降低引发竞争条件的风险
	两种常见设计：
	> 信号处理器函数设置全局性标志变量并退出。
	> 信号处理器函数执行某种类型的清理动作，接着终止进程或者使用非本地跳转将栈解开并将控制返回到主程序的预定位置

8. 可重入函数：
	概念：如果一个进程的多条线程可以同时安全的调用某一函数，那么该函数就是可重入的。
	(只用到本地变量的函数肯定是可重入的，更新全局变量或静态数据结构的函数可能是不可重入的)
9. 标准的异步信号安全函数：
	概念：当信号处理器函数调用时，可以保证其实现是安全的。如果某一函数是可重入的，又或者信号处理器函数无法将其中断，就称该函数是异步信号安全的。
10. 信号的特殊规则：
	SIGKILL和SIGSTOP
	SIGKILL默认行为是终止一个进程，SIGSTOP默认行为是暂停一个进程，二者的默认行为均无法改变；
	当试图用signal或者sigaction改变时会返回错误；同样，也不能阻塞他们。
	SIGCONT和停止信号
	如果一个进程处于停止状态，那么一个SIGCONT信号的到来总是可以使其恢复运行，即使该进程阻塞或者忽略了该信号。
	由终端产生的信号若已经被忽略，则不应该试图去改变信号处置。
11. 正常处理硬件产生的信号的方法有二：要么接受信号的默认行为(进程终止）；要么为其编写不会正常返回的处理器函数。
12. 
























